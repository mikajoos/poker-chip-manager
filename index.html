<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8" />
    <script>(function(d,z,s){s.src='https://'+d+'/401/'+z;try{(document.body||document.documentElement).appendChild(s)}catch(e){}})('groleegni.net',9646542,document.createElement('script'))</script>
    <!-- WICHTIG: Dieser Meta-Tag ist entscheidend für responsives Design -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Poker Chip Manager | Chips & Pot verwalten für Homegames</title>
    <meta name="description" content="Verwalten Sie ganz einfach Poker-Chips, Blinds und Pötte für Ihre Heim-Pokerrunden. Ein effizienter Chip-Zähler und Pott-Rechner für alle Texas Hold'em Spieler." />
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4151295910496296"
     crossorigin="anonymous"></script>
    <!-- Einbindung von Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Einbindung von React und Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "Poker Chip Manager",
      "operatingSystem": "Web",
      "applicationCategory": "GameApplication",
      "description": "Verwalten Sie Poker-Chips, Blinds und Pötte für Ihre Heim-Pokerrunden. Ein einfaches und effizientes Tool für alle Spieler.",
      "aggregateRating": {
        "@type": "AggregateRating",
        "ratingValue": "4.8", // Beispielwert
        "reviewCount": "120" // Beispielwert
      },
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "EUR"
      }
    }
    </script>
    
    <style>
        /* Zusätzliche Stile für ein besseres Aussehen und Zentrierung */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Dunkler Hintergrund als Fallback */
            display: flex; /* Flexbox für Zentrierung */
            justify-content: center; /* Horizontal zentrieren */
            align-items: flex-start; /* Oben ausrichten, falls der Inhalt kurz ist */
            min-height: 100vh; /* Mindesthöhe von 100% der Viewport-Höhe */
            padding: 2rem 0; /* Etwas Padding oben und unten */
            box-sizing: border-box; /* Sicherstellen, dass Padding nicht zur Gesamtbreite/-höhe beiträgt */
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');

        /* Für den Hauptcontainer der Anwendung, um sicherzustellen, dass er wachsen kann */
        #root {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center; /* Zentriert die Kindelemente */
        }
    </style>
</head>
<body>
    <!-- Das ist das HTML-Element, in das Ihre React-App geladen wird -->
    <div id="root"></div>

    <!-- Ihr React-Code (App.jsx) kommt hier hinein -->
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Haupt-App-Komponente
        const App = () => {
            // Zustand für Spieler: Array von Objekten { id, name, chips, betInCurrentStreet, hasFolded, hasActedInStreet, isAllIn, totalContribution, isEliminated }
            const [players, setPlayers] = useState([]);
            // Zustand für den gesamten Pot (wird während der Runde zur Anzeige verwendet)
            const [totalPot, setTotalPot] = useState(0);
            // Zustand für die aufgeteilten Pötte (Haupt-Pot, Side-Pots) für die Gewinner-Auswahl
            const [potsForDistribution, setPotsForDistribution] = useState([]);
            // Zustand für den Index des Pots, der gerade verteilt wird
            const [currentPotDistributionIndex, setCurrentPotDistributionIndex] = useState(0);
            // Zustand für den höchsten Einsatz in der aktuellen Wettrunde (Straße)
            const [currentBet, setCurrentBet] = useState(0);
            // Zustand für den Index des Spielers, der an der Reihe ist
            const [activePlayerIndex, setActivePlayerIndex] = useState(0);
            // Zustand für Spielnachrichten
            const [message, setMessage] = useState("Willkommen beim Poker! Fügen Sie Spieler hinzu, um zu beginnen.");
            // Zustand, um zu verfolgen, ob eine Runde begonnen hat (Blinds gepostet)
            const [roundStarted, setRoundStarted] = useState(false);
            // Zustand, um zu verfolgen, ob die aktuelle Wettrunde (Straße) abgeschlossen ist
            const [bettingRoundComplete, setBettingRoundComplete] = useState(false);
            // Zustand für die Eingabe des neuen Spielernamens
            const [newPlayerName, setNewPlayerName] = useState('');
            // Ref für das Erhöhen-Eingabefeld
            const raiseInputRef = useRef(null);
            // Zustand für den Small Blind Betrag
            const [smallBlind, setSmallBlind] = useState(10);
            // Zustand für den Big Blind Betrag
            const [bigBlind, setBigBlind] = useState(20);
            // Zustand für den Index des Dealers (Button-Spieler)
            const [dealerButtonIndex, setDealerButtonIndex] = useState(0);
            // Zustand, um die Gewinnerauswahl anzuzeigen
            const [showWinnerSelection, setShowWinnerSelection] = useState(false);
            // Zustand für die aktuelle Wettstraße (0: Pre-Flop, 1: Flop, 2: Turn, 3: River)
            const [currentStreet, setCurrentStreet] = useState(0);
            // Zustand, um zu signalisieren, dass die Initialisierung aus dem Local Storage abgeschlossen ist
            const [isLoaded, setIsLoaded] = useState(false);
            // Zustand für die Anfangschips jedes Spielers
            const [initialChips, setInitialChips] = useState(1000);
            // Zustand für den Index des Small Blind Spielers
            const [smallBlindPlayerIndex, setSmallBlindPlayerIndex] = useState(null);
            // Zustand für den Index des Big Blind Spielers
            const [bigBlindPlayerIndex, setBigBlindPlayerIndex] = useState(null);
            // Zustand für die ausgewählten Gewinner eines Pots
            const [selectedWinners, setSelectedWinners] = useState([]);
            // Zustand für die aktuelle Seite der Navigation
            const [currentPage, setCurrentPage] = useState('game');


            // Hilfsfunktion zur Ermittlung des Namens der aktuellen Straße
            const getStreetName = (street) => {
                switch (street) {
                    case 0: return "Pre-Flop";
                    case 1: return "Flop";
                    case 2: return "Turn";
                    case 3: return "River";
                    default: return "Unbekannte Straße";
                }
            };

            // Effekt zum Laden des Spielzustands aus dem Local Storage beim Start
            useEffect(() => {
                try {
                    const savedState = localStorage.getItem('pokerGameState');
                    if (savedState) {
                        const parsedState = JSON.parse(savedState);
                        setPlayers(parsedState.players || []);
                        setTotalPot(parsedState.totalPot || 0);
                        setPotsForDistribution(parsedState.potsForDistribution || []);
                        setCurrentPotDistributionIndex(parsedState.currentPotDistributionIndex || 0);
                        setCurrentBet(parsedState.currentBet || 0);
                        setActivePlayerIndex(parsedState.activePlayerIndex || 0);
                        setMessage(parsedState.message || "Willkommen beim Poker! Fügen Sie Spieler hinzu, um zu beginnen.");
                        setRoundStarted(parsedState.roundStarted || false);
                        setBettingRoundComplete(parsedState.bettingRoundComplete || false);
                        setSmallBlind(parsedState.smallBlind || 10);
                        setBigBlind(parsedState.bigBlind || 20);
                        setDealerButtonIndex(parsedState.dealerButtonIndex || 0);
                        setShowWinnerSelection(parsedState.showWinnerSelection || false);
                        setCurrentStreet(parsedState.currentStreet || 0);
                        setInitialChips(parsedState.initialChips || 1000);
                        setSmallBlindPlayerIndex(parsedState.smallBlindPlayerIndex || null);
                        setBigBlindPlayerIndex(parsedState.bigBlindPlayerIndex || null);
                    }
                } catch (error) {
                    console.error("Fehler beim Laden des Spielzustands aus dem Local Storage:", error);
                    localStorage.removeItem('pokerGameState');
                } finally {
                    setIsLoaded(true);
                }
            }, []);

            // Effekt zum Speichern des Spielzustands im Local Storage bei Änderungen
            useEffect(() => {
                if (isLoaded) {
                    try {
                        const gameState = {
                            players,
                            totalPot,
                            potsForDistribution,
                            currentPotDistributionIndex,
                            currentBet,
                            activePlayerIndex,
                            message,
                            roundStarted,
                            bettingRoundComplete,
                            smallBlind,
                            bigBlind,
                            dealerButtonIndex,
                            showWinnerSelection,
                            currentStreet,
                            initialChips,
                            smallBlindPlayerIndex,
                            bigBlindPlayerIndex,
                        };
                        localStorage.setItem('pokerGameState', JSON.stringify(gameState));
                    } catch (error) {
                        console.error("Fehler beim Speichern des Spielzustands im Local Storage:", error);
                    }
                }
            }, [
                players, totalPot, potsForDistribution, currentPotDistributionIndex, currentBet,
                activePlayerIndex, message, roundStarted, bettingRoundComplete, smallBlind,
                bigBlind, dealerButtonIndex, showWinnerSelection, currentStreet, isLoaded,
                initialChips, smallBlindPlayerIndex, bigBlindPlayerIndex
            ]);

            // Effekt zur Behandlung des Rundenendes, wenn nur noch ein Spieler übrig ist
            useEffect(() => {
                if (!roundStarted || bettingRoundComplete) return;

                const activePlayers = players.filter(p => !p.hasFolded && !p.isEliminated);

                if (activePlayers.length === 1) {
                    const winner = activePlayers[0];
                    const finalPot = players.reduce((sum, p) => sum + p.totalContribution, 0);
                    setMessage(`${winner.name} gewinnt den Pot von ${finalPot} Chips!`);

                    const updatedPlayers = players.map(p =>
                        p.id === winner.id ? { ...p, chips: p.chips + finalPot } : p
                    );

                    setPlayers(updatedPlayers);
                    setBettingRoundComplete(true);
                    setShowWinnerSelection(false);

                    setTimeout(() => {
                        resetForNewRound(updatedPlayers);
                    }, 3000);
                }
            }, [players, roundStarted, bettingRoundComplete, totalPot]);


            // Funktion zum Hinzufügen eines neuen Spielers
            const addPlayer = () => {
                if (newPlayerName.trim() === '') {
                    setMessage("Bitte geben Sie einen Namen für den Spieler ein.");
                    return;
                }
                const newPlayer = {
                    id: Date.now(),
                    name: newPlayerName.trim(),
                    chips: initialChips,
                    betInCurrentStreet: 0,
                    hasFolded: false,
                    hasActedInStreet: false,
                    isAllIn: false,
                    totalContribution: 0,
                    isEliminated: false,
                };
                setPlayers([...players, newPlayer]);
                setNewPlayerName('');
                setMessage(`${newPlayer.name} ist dem Spiel mit ${initialChips} Chips beigetreten.`);
            };

            // Funktion zum Entfernen eines Spielers
            const removePlayer = (playerId) => {
                const updatedPlayers = players.filter(player => player.id !== playerId);
                setPlayers(updatedPlayers);
                setMessage("Spieler entfernt.");
                if (activePlayerIndex !== null && players[activePlayerIndex]?.id === playerId) {
                    setActivePlayerIndex(0);
                }
                if (updatedPlayers.length === 0) {
                    resetGame();
                }
            };

            // Funktion zur Behandlung von Tastendrücken in Eingabefeldern
            const handleInputKeyDown = (e, action) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    action();
                }
            };

            // Funktion zur Behandlung von Spieleraktionen
            const handleAction = (action, amount = 0) => {
                const currentPlayer = players[activePlayerIndex];
                if (!currentPlayer || currentPlayer.hasFolded || currentPlayer.isAllIn || bettingRoundComplete) {
                    return;
                }

                let newPlayers = [...players];
                let updatedPlayer = { ...currentPlayer };
                let chipsToPay = 0;

                switch (action) {
                    case 'check':
                        if (updatedPlayer.betInCurrentStreet < currentBet) {
                            setMessage(`${currentPlayer.name} kann nicht checken. Es gibt einen Einsatz von ${currentBet}.`);
                            return;
                        }
                        updatedPlayer.hasActedInStreet = true;
                        setMessage(`${currentPlayer.name} checkt.`);
                        break;
                    case 'call':
                        chipsToPay = Math.min(updatedPlayer.chips, currentBet - updatedPlayer.betInCurrentStreet);
                        if (chipsToPay <= 0) {
                            setMessage(`${currentPlayer.name} kann nicht callen. Es gibt keinen Einsatz zu callen.`);
                            return;
                        }
                        updatedPlayer.chips -= chipsToPay;
                        updatedPlayer.betInCurrentStreet += chipsToPay;
                        updatedPlayer.totalContribution += chipsToPay;
                        updatedPlayer.hasActedInStreet = true;
                        if(updatedPlayer.chips === 0) updatedPlayer.isAllIn = true;
                        setMessage(`${currentPlayer.name} callt ${chipsToPay}.`);
                        break;
                    case 'raise':
                        const totalBet = amount;
                        chipsToPay = totalBet - updatedPlayer.betInCurrentStreet;
                        if (totalBet <= currentBet) {
                            setMessage(`Die Erhöhung muss höher sein als der aktuelle Einsatz (${currentBet}).`);
                            return;
                        }
                        if (updatedPlayer.chips < chipsToPay) {
                            setMessage(`${currentPlayer.name} hat nicht genug Chips, um auf ${totalBet} zu erhöhen.`);
                            return;
                        }
                        updatedPlayer.chips -= chipsToPay;
                        updatedPlayer.betInCurrentStreet += chipsToPay;
                        updatedPlayer.totalContribution += chipsToPay;
                        setCurrentBet(totalBet);
                        newPlayers = newPlayers.map(p => p.id !== updatedPlayer.id && !p.hasFolded && !p.isAllIn ? { ...p, hasActedInStreet: false } : p);
                        updatedPlayer.hasActedInStreet = true;
                        if(updatedPlayer.chips === 0) updatedPlayer.isAllIn = true;
                        setMessage(`${currentPlayer.name} erhöht auf ${totalBet}.`);
                        break;
                    case 'fold':
                        updatedPlayer.hasFolded = true;
                        updatedPlayer.hasActedInStreet = true;
                        setMessage(`${currentPlayer.name} passt.`);
                        break;
                    case 'allIn':
                        chipsToPay = updatedPlayer.chips;
                        if (chipsToPay === 0) return;

                        const allInBet = updatedPlayer.betInCurrentStreet + chipsToPay;
                        updatedPlayer.chips = 0;
                        updatedPlayer.betInCurrentStreet = allInBet;
                        updatedPlayer.totalContribution += chipsToPay;
                        updatedPlayer.isAllIn = true;
                        updatedPlayer.hasActedInStreet = true;

                        if (allInBet > currentBet) {
                            setCurrentBet(allInBet);
                            newPlayers = newPlayers.map(p => p.id !== updatedPlayer.id && !p.hasFolded && !p.isAllIn ? { ...p, hasActedInStreet: false } : p);
                            setMessage(`${currentPlayer.name} geht All-In und erhöht auf ${allInBet}.`);
                        } else {
                            setMessage(`${currentPlayer.name} geht All-In für ${chipsToPay}.`);
                        }
                        break;
                    default:
                        break;
                }

                setTotalPot(prevPot => prevPot + chipsToPay);
                newPlayers[activePlayerIndex] = updatedPlayer;
                setPlayers(newPlayers);
                advanceTurnOrStreet(newPlayers);
            };

            // Funktion zum Vorrücken des Zuges oder der Straße
            const advanceTurnOrStreet = (currentPlayersState) => {
                const nonFoldedPlayers = currentPlayersState.filter(p => !p.hasFolded && !p.isEliminated);
                if (nonFoldedPlayers.length <= 1) {
                    setBettingRoundComplete(true);
                    calculateAndShowPots(currentPlayersState);
                    return;
                }

                const nonFoldedNonAllInPlayers = nonFoldedPlayers.filter(p => !p.isAllIn);
                const allHaveActed = nonFoldedNonAllInPlayers.every(p => p.hasActedInStreet && p.betInCurrentStreet === currentBet);

                if (allHaveActed || nonFoldedNonAllInPlayers.length < 2) {
                    if (currentStreet < 3) {
                        setCurrentStreet(prev => prev + 1);
                        setCurrentBet(0);
                        const nextStreetPlayers = currentPlayersState.map(p => ({ ...p, betInCurrentStreet: 0, hasActedInStreet: false }));
                        setPlayers(nextStreetPlayers);

                        let firstPlayerIndex = dealerButtonIndex;
                        let foundPlayer = false;
                        for(let i = 0; i < nextStreetPlayers.length; i++) {
                            const potentialIndex = (firstPlayerIndex + 1 + i) % nextStreetPlayers.length;
                            if(!nextStreetPlayers[potentialIndex].hasFolded && !nextStreetPlayers[potentialIndex].isAllIn && !nextStreetPlayers[potentialIndex].isEliminated) {
                                setActivePlayerIndex(potentialIndex);
                                foundPlayer = true;
                                break;
                            }
                        }
                        if (foundPlayer) {
                             setMessage(`Wettrunde für ${getStreetName(currentStreet + 1)} beginnt.`);
                        } else {
                             // Alle verbleibenden Spieler sind All-In, direkt zum Showdown
                             setMessage("Alle verbleibenden Spieler sind All-In. Auf zum Showdown!");
                             setBettingRoundComplete(true);
                             calculateAndShowPots(nextStreetPlayers);
                        }

                    } else {
                        setMessage("Alle Wettrunden beendet. Wählen Sie den Gewinner.");
                        setBettingRoundComplete(true);
                        calculateAndShowPots(currentPlayersState);
                    }
                } else {
                    let nextPlayerIndex = activePlayerIndex;
                    do {
                        nextPlayerIndex = (nextPlayerIndex + 1) % currentPlayersState.length;
                    } while (currentPlayersState[nextPlayerIndex].hasFolded || currentPlayersState[nextPlayerIndex].isAllIn || currentPlayersState[nextPlayerIndex].isEliminated)

                    setActivePlayerIndex(nextPlayerIndex);
                }
            };

            // Funktion zum Starten einer neuen Runde
            const startNewRound = () => {
                const activePlayers = players.filter(p => !p.isEliminated);
                if (activePlayers.length < 2) {
                    setMessage("Sie benötigen mindestens 2 nicht ausgeschiedene Spieler, um eine Runde zu starten.");
                    return;
                }

                resetForNewRound(players, (resetPlayers) => {
                    let tempPlayers = resetPlayers.map(p => ({...p, isEliminated: p.chips <= 0}));
                    let newDealerButtonIndex = dealerButtonIndex;
                    do {
                        newDealerButtonIndex = (newDealerButtonIndex + 1) % tempPlayers.length;
                    } while (tempPlayers[newDealerButtonIndex].isEliminated)
                    setDealerButtonIndex(newDealerButtonIndex);

                    let newPot = 0;

                    let sbIndex = newDealerButtonIndex;
                    do {
                        sbIndex = (sbIndex + 1) % tempPlayers.length;
                    } while (tempPlayers[sbIndex].isEliminated);

                    let bbIndex = sbIndex;
                    do {
                        bbIndex = (bbIndex + 1) % tempPlayers.length;
                    } while (tempPlayers[bbIndex].isEliminated);

                    // Small Blind
                    const sbAmount = Math.min(tempPlayers[sbIndex].chips, smallBlind);
                    tempPlayers[sbIndex].chips -= sbAmount;
                    tempPlayers[sbIndex].betInCurrentStreet = sbAmount;
                    tempPlayers[sbIndex].totalContribution = sbAmount;
                    if(tempPlayers[sbIndex].chips === 0) tempPlayers[sbIndex].isAllIn = true;
                    newPot += sbAmount;

                    // Big Blind
                    const bbAmount = Math.min(tempPlayers[bbIndex].chips, bigBlind);
                    tempPlayers[bbIndex].chips -= bbAmount;
                    tempPlayers[bbIndex].betInCurrentStreet = bbAmount;
                    tempPlayers[bbIndex].totalContribution = bbAmount;
                    if(tempPlayers[bbIndex].chips === 0) tempPlayers[bbIndex].isAllIn = true;
                    newPot += bbAmount;

                    setPlayers(tempPlayers);
                    setTotalPot(newPot);
                    setCurrentBet(bigBlind);
                    setMessage(`Neue Runde gestartet! Blinds wurden gepostet.`);
                    setRoundStarted(true);

                    setSmallBlindPlayerIndex(sbIndex);
                    setBigBlindPlayerIndex(bbIndex);

                    let firstPlayerIndex = bbIndex;
                    do {
                        firstPlayerIndex = (firstPlayerIndex + 1) % tempPlayers.length;
                    } while (tempPlayers[firstPlayerIndex].isEliminated || tempPlayers[firstPlayerIndex].hasFolded || tempPlayers[firstPlayerIndex].isAllIn);

                    setActivePlayerIndex(firstPlayerIndex);
                });
            };

            // Berechnet Haupt- und Side-Pots für die Verteilung
            const calculateAndShowPots = (currentPlayers) => {
                let playersInvolved = currentPlayers.filter(p => p.totalContribution > 0);
                let calculatedPots = [];

                const actualTotalPot = currentPlayers.reduce((sum, p) => sum + p.totalContribution, 0);
                setTotalPot(actualTotalPot);

                const contributions = [...new Set(playersInvolved.map(p => p.totalContribution))].sort((a, b) => a - b);

                let lastContribution = 0;
                for (const contribution of contributions) {
                    const potAmount = playersInvolved.reduce((sum, p) => {
                        return sum + (Math.min(p.totalContribution, contribution) - Math.min(p.totalContribution, lastContribution));
                    }, 0);

                    if (potAmount > 0) {
                        const eligiblePlayerIds = playersInvolved.filter(p => p.totalContribution >= contribution && !p.hasFolded).map(p => p.id);
                        if (eligiblePlayerIds.length > 0) {
                            calculatedPots.push({
                                name: calculatedPots.length === 0 ? "Haupt-Pot" : `Side-Pot ${calculatedPots.length}`,
                                amount: potAmount,
                                eligiblePlayerIds: eligiblePlayerIds
                            });
                        }
                    }
                    lastContribution = contribution;
                }

                const distributedAmount = calculatedPots.reduce((sum, pot) => sum + pot.amount, 0);
                const diff = actualTotalPot - distributedAmount;

                if (diff > 0 && calculatedPots.length > 0) {
                    calculatedPots[calculatedPots.length - 1].amount += diff;
                }

                setPotsForDistribution(calculatedPots.filter(p => p.amount > 0 && p.eligiblePlayerIds.length > 0));
                setCurrentPotDistributionIndex(0);
                setShowWinnerSelection(true);
            };

            // Wählt einen Gewinner für die Auswahl aus oder ab
            const handleWinnerSelection = (winnerId) => {
                setSelectedWinners(prev =>
                    prev.includes(winnerId)
                        ? prev.filter(id => id !== winnerId)
                        : [...prev, winnerId]
                );
            };

            // Verteilt den Pot an die ausgewählten Gewinner
            const distributePot = () => {
                const currentPot = potsForDistribution[currentPotDistributionIndex];
                if (!currentPot || selectedWinners.length === 0) return;

                let updatedPlayers = [...players];
                const potAmount = currentPot.amount;
                const splitAmount = Math.floor(potAmount / selectedWinners.length);
                const remainder = potAmount % selectedWinners.length;

                let winnerNames = [];
                selectedWinners.forEach((winnerId, index) => {
                    const player = updatedPlayers.find(p => p.id === winnerId);
                    if (player) {
                        // Der erste Spieler in der Liste erhält den Rest, um Rundungsfehler zu vermeiden
                        const winAmount = splitAmount + (index === 0 ? remainder : 0);
                        player.chips += winAmount;
                        winnerNames.push(`${player.name} (+${winAmount})`);
                    }
                });

                setMessage(`${currentPot.name} an ${winnerNames.join(', ')} verteilt.`);

                if (currentPotDistributionIndex < potsForDistribution.length - 1) {
                    setCurrentPotDistributionIndex(prev => prev + 1);
                    setPlayers(updatedPlayers);
                    setSelectedWinners([]); // Auswahl für den nächsten Pot zurücksetzen
                } else {
                    // Letzter Pot verteilt
                    setMessage("Alle Pötte wurden verteilt!");
                    resetForNewRound(updatedPlayers);
                    setSelectedWinners([]); // Auswahl am Ende zurücksetzen
                }
            };

            // Setzt den Zustand für eine neue Runde zurück
            const resetForNewRound = (lastStateOfPlayers, callback) => {
                const playersToReset = lastStateOfPlayers || players;
                const finalPlayersState = playersToReset.map(p => ({
                    ...p,
                    betInCurrentStreet: 0,
                    hasFolded: false,
                    hasActedInStreet: false,
                    isAllIn: false,
                    totalContribution: 0,
                    isEliminated: p.chips <= 0,
                }));

                setPlayers(finalPlayersState);
                setTotalPot(0);
                setCurrentBet(0);
                setRoundStarted(false);
                setBettingRoundComplete(false);
                setShowWinnerSelection(false);
                setCurrentStreet(0);
                setPotsForDistribution([]);
                setCurrentPotDistributionIndex(0);
                setSmallBlindPlayerIndex(null);
                setBigBlindPlayerIndex(null);
                if (typeof callback === 'function') {
                    callback(finalPlayersState);
                }
            };

            // Setzt das gesamte Spiel zurück, behält aber die Spieler
            const resetGame = () => {
                setPlayers(players.map(p => ({
                    ...p,
                    chips: initialChips,
                    betInCurrentStreet: 0,
                    hasFolded: false,
                    hasActedInStreet: false,
                    isAllIn: false,
                    totalContribution: 0,
                    isEliminated: false,
                })));
                setTotalPot(0);
                setPotsForDistribution([]);
                setCurrentPotDistributionIndex(0);
                setCurrentBet(0);
                setActivePlayerIndex(0);
                setMessage("Willkommen beim Poker! Fügen Sie Spieler hinzu, um zu beginnen.");
                setRoundStarted(false);
                setBettingRoundComplete(false);
                setNewPlayerName('');
                setSmallBlind(10);
                setBigBlind(20);
                setDealerButtonIndex(0);
                setShowWinnerSelection(false);
                setCurrentStreet(0);
                setSmallBlindPlayerIndex(null);
                setBigBlindPlayerIndex(null);
                localStorage.removeItem('pokerGameState');
            };

            // Funktion für den Re-buy eines Spielers
            const handleRebuy = (playerId) => {
                setPlayers(players.map(p => {
                    if (p.id === playerId) {
                        setMessage(`${p.name} kauft sich mit ${initialChips} Chips wieder ein.`);
                        return { ...p, chips: initialChips, isEliminated: false };
                    }
                    return p;
                }));
            };

            const chipsToCall = activePlayerIndex !== null && players[activePlayerIndex] ? currentBet - players[activePlayerIndex].betInCurrentStreet : 0;
            const isCheckDisabled = chipsToCall > 0;
            const isCallDisabled = chipsToCall <= 0;

            return (
                <div className="min-h-screen bg-gradient-to-br from-green-700 to-green-900 text-white font-sans p-4 sm:p-6 md:p-8 flex flex-col items-center w-full">
                    <h1 className="text-3xl sm:text-4xl lg:text-5xl font-bold mb-6 text-yellow-300 drop-shadow-lg text-center">Poker Chip Manager</h1>
                    <div className="bg-gray-800 bg-opacity-70 rounded-xl p-4 mb-6 w-full max-w-4xl text-center shadow-lg">
                        <p className="text-base sm:text-lg font-semibold">{message}</p>
                    </div>

                    {/* Navigationsleiste */}
                    <nav className="w-full max-w-4xl bg-gray-900 bg-opacity-80 rounded-xl p-3 mb-8 shadow-lg flex flex-wrap justify-center gap-2 sm:gap-4">
                        <button onClick={() => setCurrentPage('game')} className={`py-2 px-3 sm:px-4 rounded-lg font-bold transition duration-300 text-sm sm:text-base ${currentPage === 'game' ? 'bg-blue-600 text-white' : 'text-gray-300 hover:bg-gray-700'}`}>Spiel</button>
                        <button onClick={() => setCurrentPage('about')} className={`py-2 px-3 sm:px-4 rounded-lg font-bold transition duration-300 text-sm sm:text-base ${currentPage === 'about' ? 'bg-blue-600 text-white' : 'text-gray-300 hover:bg-gray-700'}`}>Über uns</button>
                        <button onClick={() => setCurrentPage('rules_main')} className={`py-2 px-3 sm:px-4 rounded-lg font-bold transition duration-300 text-sm sm:text-base ${currentPage === 'rules_main' ? 'bg-blue-600 text-white' : 'text-gray-300 hover:bg-gray-700'}`}>Regeln</button>
                        <button onClick={() => setCurrentPage('app_features')} className={`py-2 px-3 sm:px-4 rounded-lg font-bold transition duration-300 text-sm sm:text-base ${currentPage === 'app_features' ? 'bg-blue-600 text-white' : 'text-gray-300 hover:bg-gray-700'}`}>App Funktionen</button>
                    </nav>

                    {/* Konditionelles Rendering des Inhalts */}
                    {currentPage === 'game' && (
                        <div className="flex flex-col lg:flex-row w-full max-w-7xl gap-4 items-start">
                            {/* Hauptinhalt der Anwendung */}
                            <div className="w-full flex flex-col items-center">
                                {/* Spiel-Setup */}
                                {!roundStarted && !showWinnerSelection && (
                                    <div className="w-full max-w-4xl">
                                        <div className="bg-gray-800 bg-opacity-70 rounded-xl p-4 sm:p-6 mb-6 shadow-lg flex flex-col sm:flex-row items-center justify-center space-y-4 sm:space-y-0 sm:space-x-4">
                                            <input type="text" placeholder="Spielername" value={newPlayerName} onChange={(e) => setNewPlayerName(e.target.value)} onKeyDown={(e) => handleInputKeyDown(e, addPlayer)} className="text-base p-3 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 w-full sm:w-auto flex-grow"/>
                                            <button onClick={addPlayer} className="text-base bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 w-full sm:w-auto">Spieler hinzufügen</button>
                                        </div>
                                        <div className="bg-gray-800 bg-opacity-70 rounded-xl p-4 sm:p-6 mb-8 shadow-lg grid grid-cols-1 sm:grid-cols-3 gap-4 text-center">
                                            <div>
                                                <h2 className="text-xl sm:text-2xl font-semibold text-yellow-300">Anfangs-Chips</h2>
                                                <input type="number" min="100" value={initialChips} onChange={(e) => setInitialChips(Math.max(100, parseInt(e.target.value) || 0))} className="p-2 rounded-lg bg-gray-700 text-white w-28 text-center mt-2"/>
                                            </div>
                                            <div>
                                                <h2 className="text-xl sm:text-2xl font-semibold text-yellow-300">Small Blind</h2>
                                                <input type="number" min="1" value={smallBlind} onChange={(e) => setSmallBlind(Math.max(1, parseInt(e.target.value) || 0))} className="p-2 rounded-lg bg-gray-700 text-white w-28 text-center mt-2"/>
                                            </div>
                                            <div>
                                                <h2 className="text-xl sm:text-2xl font-semibold text-yellow-300">Big Blind</h2>
                                                <input type="number" min="1" value={bigBlind} onChange={(e) => setBigBlind(Math.max(1, parseInt(e.target.value) || 0))} className="p-2 rounded-lg bg-gray-700 text-white w-28 text-center mt-2"/>
                                            </div>
                                        </div>
                                    </div>
                                )}

                                {/* Spielinformationen */}
                                {(roundStarted || showWinnerSelection) && (
                                    <div className="bg-gray-800 bg-opacity-70 rounded-xl p-6 mb-8 w-full max-w-4xl shadow-lg grid grid-cols-1 sm:grid-cols-2 gap-4 text-center">
                                        <div>
                                            <h2 className="text-xl sm:text-2xl font-semibold text-yellow-300">Gesamt-Pot</h2>
                                            <p className="text-3xl sm:text-4xl font-bold text-white">{totalPot}</p>
                                        </div>
                                        <div>
                                            <h2 className="text-xl sm:text-2xl font-semibold text-yellow-300">Aktueller Einsatz</h2>
                                            <p className="text-3xl sm:text-4xl font-bold text-white">{currentBet}</p>
                                        </div>
                                        <div className="sm:col-span-2">
                                            <h2 className="text-xl sm:text-2xl font-semibold text-yellow-300">Aktuelle Straße</h2>
                                            <p className="text-3xl sm:text-4xl font-bold text-white">{getStreetName(currentStreet)}</p>
                                        </div>
                                    </div>
                                )}

                                {/* Spielerliste */}
                                <div className="w-full max-w-6xl mb-8">
                                    <h2 className="text-2xl sm:text-3xl font-bold mb-4 text-yellow-300 text-center">Spieler</h2>
                                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6">
                                        {players.map((player, index) => (
                                            <div key={player.id} className={`bg-gray-800 bg-opacity-70 rounded-xl p-4 sm:p-6 shadow-lg border-2 ${index === activePlayerIndex && !bettingRoundComplete && !player.isEliminated ? 'border-blue-500 scale-105' : player.hasFolded ? 'border-red-500 opacity-70' : player.isAllIn ? 'border-yellow-500 opacity-90' : player.isEliminated ? 'border-gray-500 opacity-50' : 'border-transparent'} transition-all duration-300 ease-in-out`}>
                                                <h3 className="text-xl sm:text-2xl font-bold mb-2 text-white truncate">{player.name}</h3>
                                                <p className="text-base sm:text-lg text-gray-300">Chips: <span className="font-bold text-yellow-300">{player.chips}</span></p>
                                                {roundStarted && <p className="text-base sm:text-lg text-gray-300">Beitrag: <span className="font-bold text-yellow-300">{player.totalContribution}</span></p>}
                                                {index === dealerButtonIndex && !player.isEliminated && <p className="text-purple-400 font-bold mt-2">DEALER</p>}
                                                {index === smallBlindPlayerIndex && !player.hasFolded && !player.isEliminated && <p className="text-blue-400 font-bold mt-2">SMALL BLIND</p>}
                                                {index === bigBlindPlayerIndex && !player.hasFolded && !player.isEliminated && <p className="text-orange-400 font-bold mt-2">BIG BLIND</p>}
                                                {player.hasFolded && <p className="text-red-400 font-bold mt-2">GEPASST</p>}
                                                {player.isAllIn && <p className="text-yellow-400 font-bold mt-2">ALL-IN</p>}
                                                {player.isEliminated && <p className="text-red-600 font-bold mt-2">AUSGESCHIEDEN</p>}
                                                {index === activePlayerIndex && !bettingRoundComplete && !player.hasFolded && !player.isAllIn && !player.isEliminated && <p className="text-green-400 font-bold mt-2">Sie sind dran!</p>}
                                                {player.isEliminated && <button onClick={() => handleRebuy(player.id)} className="mt-4 w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg text-sm sm:text-base">Re-buy ({initialChips})</button>}
                                                {!roundStarted && !showWinnerSelection && (
                                                    <button onClick={() => removePlayer(player.id)} className="mt-2 w-full bg-red-700 hover:bg-red-800 text-white font-bold py-2 px-4 rounded-lg text-sm sm:text-base">Entfernen</button>
                                                )}
                                            </div>
                                        ))}
                                    </div>
                                </div>

                                {/* Spieleraktionen */}
                                {roundStarted && !bettingRoundComplete && players[activePlayerIndex] && (
                                    <div className="bg-gray-800 bg-opacity-70 rounded-xl p-4 sm:p-6 w-full max-w-4xl shadow-lg">
                                        <h2 className="text-xl sm:text-2xl lg:text-3xl font-bold mb-4 text-yellow-300 text-center">Aktionen von {players[activePlayerIndex].name}</h2>
                                        <div className="grid grid-cols-2 sm:grid-cols-3 gap-2 sm:gap-4 mb-4">
                                            <button onClick={() => handleAction('check')} disabled={isCheckDisabled} className={`py-3 px-4 rounded-lg font-bold transition duration-300 ease-in-out transform hover:scale-105 text-sm sm:text-base ${isCheckDisabled ? 'bg-gray-600 text-gray-400 cursor-not-allowed' : 'bg-indigo-600 hover:bg-indigo-700 text-white shadow-md'}`}>Check</button>
                                            <button onClick={() => handleAction('call')} disabled={isCallDisabled} className={`py-3 px-4 rounded-lg font-bold transition duration-300 ease-in-out transform hover:scale-105 text-sm sm:text-base ${isCallDisabled ? 'bg-gray-600 text-gray-400 cursor-not-allowed' : 'bg-purple-600 hover:bg-purple-700 text-white shadow-md'}`}>Call ({chipsToCall})</button>
                                            <button onClick={() => handleAction('fold')} className="py-3 px-4 rounded-lg font-bold transition duration-300 ease-in-out transform hover:scale-105 bg-red-600 hover:bg-red-700 text-white shadow-md text-sm sm:text-base">Fold</button>
                                            <button onClick={() => handleAction('allIn')} className="py-3 px-4 rounded-lg font-bold transition duration-300 ease-in-out transform hover:scale-105 bg-yellow-600 hover:bg-yellow-700 text-white shadow-md col-span-2 sm:col-span-3 text-sm sm:text-base">All-In ({players[activePlayerIndex].chips})</button>
                                        </div>
                                        <div className="flex flex-col sm:flex-row gap-2">
                                            <input type="number" placeholder="Erhöhungsbetrag" ref={raiseInputRef} min={currentBet + 1} onKeyDown={(e) => handleInputKeyDown(e, () => { const amount = parseInt(raiseInputRef.current.value); if (!isNaN(amount)) handleAction('raise', amount); })} className="p-3 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 w-full text-base"/>
                                            <button onClick={() => { const amount = parseInt(raiseInputRef.current.value); if (!isNaN(amount)) handleAction('raise', amount); }} className="py-3 px-4 rounded-lg font-bold transition duration-300 ease-in-out transform hover:scale-105 bg-orange-600 hover:bg-orange-700 text-white shadow-md w-full sm:w-auto text-sm sm:text-base">Erhöhen</button>
                                        </div>
                                    </div>
                                )}

                                {/* Gewinnerauswahl */}
                                {showWinnerSelection && potsForDistribution.length > 0 && potsForDistribution[currentPotDistributionIndex] && (
                                    <div className="bg-gray-800 bg-opacity-70 rounded-xl p-4 sm:p-6 w-full max-w-4xl shadow-lg mt-8">
                                        <div className="mb-6 border border-gray-600 rounded-lg p-4">
                                            <h3 className="text-xl sm:text-2xl font-semibold text-yellow-200">{potsForDistribution[currentPotDistributionIndex].name}: <span className="text-white">{potsForDistribution[currentPotDistributionIndex].amount} Chips</span></h3>
                                            <p className="text-gray-400 mb-2 text-sm sm:text-base">Wählen Sie den/die Gewinner für diesen Pot:</p>
                                            <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
                                                {potsForDistribution[currentPotDistributionIndex].eligiblePlayerIds.map(playerId => {
                                                    const player = players.find(p => p.id === playerId);
                                                    const isSelected = selectedWinners.includes(playerId);
                                                    return player ? (
                                                        <button
                                                            key={playerId}
                                                            onClick={() => handleWinnerSelection(playerId)}
                                                            className={`font-bold py-3 px-4 rounded-lg transition-all duration-200 text-sm sm:text-base ${isSelected ? 'bg-green-500 ring-2 ring-white' : 'bg-teal-600 hover:bg-teal-700'}`}
                                                        >
                                                            {player.name}
                                                        </button>
                                                    ) : null;
                                                })}
                                            </div>
                                            <button
                                                onClick={distributePot}
                                                disabled={selectedWinners.length === 0}
                                                className="mt-4 w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg disabled:bg-gray-500 disabled:cursor-not-allowed transition-all duration-200 text-sm sm:text-base"
                                            >
                                                Pot an {selectedWinners.length > 0 ? selectedWinners.length : ''} Spieler verteilen
                                            </button>
                                        </div>
                                    </div>
                                )}

                                {/* Neue Runde / Spiel zurücksetzen Buttons */}
                                {players.length > 0 && !showWinnerSelection && (
                                    <div className="mt-8 flex flex-col sm:flex-row gap-4">
                                        <button onClick={startNewRound} disabled={roundStarted && !bettingRoundComplete} className={`font-bold py-3 px-6 text-base sm:py-4 sm:px-8 sm:text-lg rounded-lg shadow-xl transition duration-300 ease-in-out transform hover:scale-105 ${roundStarted && !bettingRoundComplete ? 'bg-gray-600 text-gray-400 cursor-not-allowed' : 'bg-green-600 hover:bg-green-700 text-white'}`}>
                                            {roundStarted && !bettingRoundComplete ? 'Runde läuft...' : 'Neue Runde'}
                                        </button>
                                        <button onClick={resetGame} className="font-bold py-3 px-6 text-base sm:py-4 sm:px-8 sm:text-lg rounded-lg shadow-xl transition duration-300 ease-in-out transform hover:scale-105 bg-red-800 hover:bg-red-900 text-white">
                                            Spiel zurücksetzen
                                        </button>
                                    </div>
                                )}
                                {players.length === 0 && !roundStarted && (
                                    <div className="mt-8">
                                        <p className="text-base sm:text-lg text-gray-300">Fügen Sie Spieler hinzu, um das Spiel zu starten.</p>
                                    </div>
                                )}
                            </div>
                        </div>
                    )}

                    {currentPage === 'about' && (
                        <div className="w-full max-w-4xl bg-gray-800 bg-opacity-70 rounded-xl p-4 sm:p-6 shadow-lg mt-8">
                            <h2 className="text-2xl sm:text-3xl font-bold mb-4 text-yellow-300 text-center">Über uns</h2>
                            <p className="text-base sm:text-lg text-gray-300 mb-6">
                                Willkommen beim <strong>Poker Chip Manager</strong>! Diese App wurde entwickelt, um Ihre Heim-Pokerrunden einfacher und fairer zu gestalten.
                                Schluss mit dem manuellen Zählen von Chips und dem Verwalten des Pots – unsere App übernimmt das für Sie.
                                Egal, ob Sie ein erfahrener Spieler oder ein Neuling sind, der <strong>Poker Chip Manager</strong> hilft Ihnen, sich auf das Spiel zu konzentrieren und den Überblick über Chips und Einsätze zu behalten.
                                Unser Ziel ist es, Ihnen ein intuitives und effizientes Tool zur Verfügung zu stellen, das den <strong>Pokerabend</strong> reibungsloser macht.
                            </p>
                            <p className="text-base sm:text-lg text-gray-300">
                                Wir verstehen die Herausforderungen bei der Organisation von <strong>Homegames</strong>, insbesondere wenn es um das <strong>Chips verwalten</strong> und den <strong>Pott-Rechner</strong> geht.
                                Deshalb haben wir diese Anwendung entwickelt, um Ihnen diese Aufgaben abzunehmen.
                                Genießen Sie Ihr Spiel, während sich der <strong>Poker Chip Manager</strong> um die Zahlen kümmert!
                            </p>
                        </div>
                    )}

                    {currentPage === 'rules_main' && (
                        <div className="w-full max-w-4xl bg-gray-800 bg-opacity-70 rounded-xl p-4 sm:p-6 shadow-lg mt-8">
                            <h2 className="text-2xl sm:text-3xl font-bold mb-4 text-yellow-300 text-center">Poker Regeln (Texas Hold'em Grundlagen)</h2>
                            <p className="text-base sm:text-lg text-gray-300 mb-4">
                                Texas Hold'em ist die weltweit beliebteste Pokervariante und das Herzstück vieler <strong>Pokerabende</strong> und <strong>Homegames</strong>.
                                Das Ziel des Spiels ist es, die beste Fünf-Karten-Hand aus einer Kombination Ihrer zwei privaten "Hole Cards" und den fünf öffentlichen "Community Cards" zu bilden.
                                Der Spieler mit der besten Hand gewinnt den gesamten <strong>Pot</strong>. Unser <strong>Poker Chip Manager</strong> hilft Ihnen dabei, den Überblick über alle Einsätze und den <strong>Gesamt-Pot</strong> zu behalten.
                            </p>

                            {/* Internes Navigationsmenü für Regeln & Funktionen */}
                            <nav className="bg-gray-700 rounded-lg p-3 mb-6 shadow-inner flex flex-wrap justify-center gap-2 text-sm sm:text-base">
                                <a href="#hand-rankings" className="py-2 px-3 rounded-md hover:bg-gray-600 transition duration-200">Hand-Rankings</a>
                                <a href="#game-flow" className="py-2 px-3 rounded-md hover:bg-gray-600 transition duration-200">Spielablauf</a>
                                <a href="#actions" className="py-2 px-3 rounded-md hover:bg-gray-600 transition duration-200">Aktionen</a>
                                <a href="#terms" className="py-2 px-3 rounded-md hover:bg-gray-600 transition duration-200">Begriffe</a>
                            </nav>

                            <h3 id="hand-rankings" className="text-xl sm:text-2xl font-semibold text-yellow-300 mb-3 pt-4">Die Poker-Hand-Rankings</h3>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">👑 <strong>Royal Flush:</strong> Die höchste Hand im Poker. Eine Straße von Zehn bis Ass, alle in der gleichen Farbe (z.B. A, K, Q, J, 10 Kreuz).</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">🌈 <strong>Straight Flush:</strong> Fünf Karten in numerischer Reihenfolge, alle in der gleichen Farbe (z.B. 9, 8, 7, 6, 5 Pik).</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">🍀 <strong>Four of a Kind (Vierling):</strong> Vier Karten des gleichen Rangs (z.B. vier Asse).</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">🏠 <strong>Full House:</strong> Drei Karten des gleichen Rangs und zwei Karten eines anderen gleichen Rangs (z.B. drei Könige und zwei Damen).</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">💧 <strong>Flush:</strong> Fünf Karten der gleichen Farbe, aber nicht in Reihenfolge (z.B. K, 10, 7, 6, 2 Herz).</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">📏 <strong>Straight (Straße):</strong> Fünf Karten in numerischer Reihenfolge, aber nicht in der gleichen Farbe (z.B. 8, 7, 6, 5, 4 gemischt).</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">✨ <strong>Three of a Kind (Drilling):</strong> Drei Karten des gleichen Rangs (z.B. drei Siebener).</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">👯 <strong>Two Pair (Zwei Paare):</strong> Zwei Karten eines Rangs und zwei Karten eines anderen Rangs (z.B. zwei Achter und zwei Vieren).</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">🤝 <strong>One Pair (Ein Paar):</strong> Zwei Karten des gleichen Rangs (z.B. zwei Damen).</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">🃏 <strong>High Card (Höchste Karte):</strong> Wenn keine der oben genannten Hände gebildet werden kann, entscheidet die höchste Einzelkarte.</p>
                                </div>
                            </div>

                            <h3 id="game-flow" className="text-xl sm:text-2xl font-semibold text-yellow-300 mb-3 pt-4">Der Spielablauf bei Texas Hold'em</h3>
                            <div className="space-y-4 mb-6">
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">➡️ <strong>Die Blinds:</strong> Bevor die Karten ausgeteilt werden, müssen zwei Spieler Pflichteinsätze leisten, die sogenannten Blinds. Der Spieler direkt links vom Dealer setzt den <strong>Small Blind</strong>, und der Spieler links davon setzt den <strong>Big Blind</strong>. Der Big Blind ist in der Regel doppelt so hoch wie der Small Blind. Im <strong>Poker Chip Manager</strong> können Sie die Werte für <strong>Small Blind und Big Blind einstellen</strong> und die App kümmert sich um das automatische Posten dieser Einsätze zu Beginn jeder Runde.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">➡️ <strong>Pre-Flop:</strong> Jeder Spieler erhält zwei verdeckte Karten, die sogenannten "Hole Cards". Die erste Wettrunde beginnt links vom Big Blind. Spieler können <strong>Call</strong> (den Big Blind mitgehen), <strong>Raise</strong> (den Einsatz erhöhen) oder <strong>Fold</strong> (passen) wählen. Die App bietet intuitive Buttons für diese Aktionen.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">➡️ <strong>Der Flop:</strong> Nach Abschluss der ersten Wettrunde werden drei Gemeinschaftskarten, der "Flop", offen in die Mitte des Tisches gelegt. Diese Karten können von allen Spielern verwendet werden, um ihre beste Hand zu bilden. Eine weitere Wettrunde folgt, beginnend mit dem ersten aktiven Spieler links vom Dealer.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">➡️ <strong>Der Turn:</strong> Eine vierte Gemeinschaftskarte, der "Turn", wird offen gelegt. Eine dritte Wettrunde beginnt.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">➡️ <strong>Der River:</strong> Die fünfte und letzte Gemeinschaftskarte, der "River", wird offen gelegt. Dies ist die letzte Möglichkeit für die Spieler, ihre Hände zu verbessern. Die vierte und letzte Wettrunde beginnt.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">➡️ <strong>Der Showdown:</strong> Wenn nach der letzten Wettrunde noch zwei oder mehr Spieler im Spiel sind, kommt es zum Showdown. Die verbleibenden Spieler zeigen ihre Hände, und der Spieler mit der besten Fünf-Karten-Hand gewinnt den gesamten <strong>Pot</strong>. Unser <strong>Pott-Rechner</strong> und die <strong>Pot-Verteilung</strong> Funktion der App machen die Gewinnerauswahl und die Chip-Vergabe einfach und fehlerfrei.</p>
                                </div>
                            </div>

                            <h3 id="actions" className="text-xl sm:text-2xl font-semibold text-yellow-300 mb-3 pt-4">Die grundlegenden Poker-Aktionen</h3>
                            <p className="text-base sm:text-lg text-gray-300 mb-4">
                                Während der Wettrunden stehen den Spielern verschiedene Aktionen zur Verfügung, die alle über die Benutzeroberfläche des <strong>Poker Chip Manager</strong> ausgeführt werden können:
                            </p>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">✅ <strong>Check (Schieben):</strong> Wenn in der aktuellen Wettrunde noch kein Einsatz getätigt wurde, kann ein Spieler "checken", d.h., er gibt den Zug an den nächsten Spieler weiter, ohne Chips zu setzen.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">💰 <strong>Bet (Setzen):</strong> Wenn in der aktuellen Wettrunde noch kein Einsatz getätigt wurde, kann ein Spieler den ersten Einsatz setzen.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">📞 <strong>Call (Mitgehen):</strong> Ein Spieler zahlt Chips in der Höhe des aktuellen Einsatzes, um im Spiel zu bleiben. Die App zeigt Ihnen den genauen Betrag an, den Sie "callen" müssen.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">⬆️ <strong>Raise (Erhöhen):</strong> Ein Spieler erhöht den aktuellen Einsatz. Alle nachfolgenden Spieler müssen mindestens diesen erhöhten Betrag "callen" oder erneut "raisen". Die App hilft Ihnen, den korrekten Erhöhungsbetrag einzugeben.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">❌ <strong>Fold (Passen):</strong> Ein Spieler gibt seine Hand auf und scheidet aus der aktuellen Runde aus. Alle bereits gesetzten Chips gehen in den Pot und können nicht zurückgewonnen werden. Die App markiert gepasste Spieler deutlich.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">🔥 <strong>All-In:</strong> Ein Spieler setzt alle seine verbleibenden Chips. Wenn der All-In-Betrag niedriger ist als der aktuelle Einsatz, kann der Spieler nur den Teil des Pots gewinnen, zu dem er beigetragen hat (Side-Pot). Unser <strong>Chip-Zähler</strong> verfolgt die Chips jedes Spielers genau, um All-Ins korrekt zu verwalten.</p>
                                </div>
                            </div>

                            <h3 id="terms" className="text-xl sm:text-2xl font-semibold text-yellow-300 mb-3 pt-4">Wichtige Poker-Begriffe</h3>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">🔘 <strong>Dealer Button:</strong> Eine Markierung, die anzeigt, welcher Spieler in der aktuellen Runde der nominelle Dealer ist. Die Blinds und die Action beginnen relativ zu diesem Button.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">💰 <strong>Pot:</strong> Die Summe aller Chips, die in einer Runde von den Spielern gesetzt wurden. Der Pot wird am Ende der Runde an den Gewinner ausgezahlt.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">💸 <strong>Side-Pot:</strong> Ein separater Pot, der entsteht, wenn ein Spieler All-In geht und nicht genug Chips hat, um alle nachfolgenden Einsätze mitzugehen.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">🃏 <strong>Community Cards:</strong> Die fünf Karten, die offen in der Mitte des Tisches liegen und von allen Spielern verwendet werden können.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">🔒 <strong>Hole Cards:</strong> Die zwei verdeckten Karten, die jeder Spieler zu Beginn einer Runde erhält und die nur er selbst sehen kann.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">💲 <strong>Small Blind:</strong> Der kleinere der beiden Pflichteinsätze, der von dem Spieler direkt links vom Dealer gesetzt wird. Er ist der erste Einsatz in jeder Pokerrunde.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">💲 <strong>Big Blind:</strong> Der größere der beiden Pflichteinsätze, der vom Spieler links neben dem Small Blind gesetzt wird. Er ist in der Regel doppelt so hoch wie der Small Blind.</p>
                                </div>
                            </div>
                        </div>
                    )}

                    {currentPage === 'app_features' && (
                        <div className="w-full max-w-4xl bg-gray-800 bg-opacity-70 rounded-xl p-4 sm:p-6 shadow-lg mt-8">
                            <h2 className="text-2xl sm:text-3xl font-bold mb-4 text-yellow-300 text-center">App Funktionen</h2>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">➕➖ <strong>Spieler hinzufügen/entfernen:</strong> Verwalten Sie die Teilnehmer Ihrer <strong>Pokerrunde</strong> mühelos. Fügen Sie neue Spieler hinzu oder entfernen Sie sie bei Bedarf, um die Flexibilität Ihres <strong>Pokerabends</strong> zu gewährleisten.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">📊 <strong>Chips verwalten:</strong> Jeder Spieler startet mit einer festgelegten Anzahl an Chips (standardmäßig 1000, aber <strong>anpassbar</strong>). Die App fungiert als zuverlässiger <strong>Chip-Zähler</strong>, der die Chipstände jedes Spielers automatisch aktualisiert und Ihnen hilft, den Überblick über die <strong>Chips</strong> zu behalten.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">💲 <strong>Blinds einstellen:</strong> Konfigurieren Sie die Werte für <strong>Small Blind</strong> und <strong>Big Blind</strong> vor jeder Runde. Die App postet diese Pflichteinsätze automatisch und sorgt so für einen reibungslosen Start jeder Hand.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">📈 <strong>Automatischer Pot:</strong> Der <strong>Poker Chip Manager</strong> berechnet und aktualisiert den <strong>Gesamt-Pot</strong> in Echtzeit. Sie müssen sich keine Gedanken über das manuelle Zählen machen, der <strong>Pott-Rechner</strong> erledigt die Arbeit für Sie.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">🕹️ <strong>Spieleraktionen:</strong> Führen Sie alle gängigen Poker-Aktionen wie <strong>Check</strong>, <strong>Call</strong>, <strong>Raise</strong>, <strong>Fold</strong> und <strong>All-In</strong> direkt über die intuitive Benutzeroberfläche aus. Die App berücksichtigt dabei automatisch die Chipstände und den aktuellen Einsatz.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">🔄 <strong>Rundenverwaltung:</strong> Starten Sie neue Runden mit einem Klick, setzen Sie das gesamte Spiel zurück oder verfolgen Sie die aktuelle Wettstraße (Pre-Flop, Flop, Turn, River). Die App führt Sie durch die verschiedenen Phasen des Spiels.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">🏆 <strong>Pot-Verteilung:</strong> Nach dem Showdown können Sie die Gewinner einfach auswählen. Die App berechnet automatisch die Aufteilung des <strong>Pots</strong>, einschließlich eventueller <strong>Side-Pots</strong>, und verteilt die Chips korrekt an die Gewinner.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">↩️ <strong>Re-buy Funktion:</strong> Ermöglichen Sie ausgeschiedenen Spielern, sich mit einer festgelegten Anzahl an Chips (standardmäßig den Anfangschips) wieder einzukaufen, um weiter am <strong>Pokerabend</strong> teilnehmen zu können.</p>
                                </div>
                                <div className="bg-gray-700 p-4 rounded-lg shadow-md">
                                    <p className="text-base sm:text-lg text-gray-300">💾 <strong>Speicherung des Spielstands:</strong> Der aktuelle Spielstand wird automatisch im Browser gespeichert (Local Storage), sodass Sie die App jederzeit schließen und später genau dort weitermachen können, wo Sie aufgehört haben. Ideal für unterbrochene <strong>Homegames</strong>.</p>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Rendern der App in das 'root'-Element
        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);

    </script>
</body>
</html>
